C51 COMPILER V9.56.0.0   C51                                                               07/13/2019 22:55:13 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE C51
OBJECT MODULE PLACED IN C51.OBJ
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE C51.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include<reg52.h>               //头文件
   2          #include<intrins.h>
   3          #include"eeprom52.h"            //STC89C52 EEPROM   程序文件
   4          
   5          #define uchar unsigned char     //宏定义
   6          #define uint unsigned int
   7          
   8          #define LCD1602_dat P0          //LCD1602数据口宏定义
   9          
  10          //sbit LCD1602_rs=P2^7;           //LCD1602控制数据IO口
  11          //sbit LCD1602_rw=P2^4;
  12          //sbit LCD1602_e=P2^6;
  13          sbit LCD1602_rs=P1^0;           //LCD1602控制数据IO口
  14          sbit LCD1602_rw=P1^1;
  15          sbit LCD1602_e=P2^5;
  16          sbit beep=P1^6;                 //蜂鸣器  IO
  17          sbit led_1=P3^0;                //LED指示灯  IO
  18          sbit led_2=P3^1;
  19          sbit key_1=P1^5;                //系统控制按键IO口
  20          sbit key_2=P3^3;
  21          sbit key_3=P3^4;
  22          sbit alarm_1=P2^5;            //控制继电器IO口
  23          
  24          
  25          sbit ADC0832_CS=P1^3;         //ADC0832  控制IO口   使能口
  26          sbit ADC0832_CLK=P1^0;        //时钟IO口
  27          sbit ADC0832_DIO=P1^1;        //数据输入输出IO口 
  28          
  29          uint sum;                     //10次AD值的综合变量
  30          uchar RH,RH_H=12,RH_L=8,state,ms,cs;  //当前水位，  水位上限，下限，  设置项变量，50ms变量   ，cs 为计次数
             -变量    ，
  31          bit beep1,zt,s1;                       //报警标志位，   工作模式标志位，   闪烁标志位
  32          
  33           
  34          unsigned int  A_D()                  //ADC0832   读值程序
  35          {
  36   1        uchar i;
  37   1        uchar dat;           
  38   1        ADC0832_CS=1;     //一个转换周期开始
  39   1        ADC0832_CLK=0;    //为第一个脉冲作准备
  40   1        ADC0832_CS=0;     //CS置0，片选有效
  41   1        ADC0832_DIO=1;    //DIO置1，规定的起始信号  
  42   1        ADC0832_CLK=1;    //第一个脉冲
  43   1        ADC0832_CLK=0;    //第一个脉冲的下降沿，此前DIO必须是高电平
  44   1        ADC0832_DIO=1;    //DIO置1， 通道选择信号  
  45   1        ADC0832_CLK=1;    //第二个脉冲，第2、3个脉冲下沉之前，DI必须跟别输入两位数据用于选择通道，这里选通道RH0 
  46   1        ADC0832_CLK=0;    //第二个脉冲下降沿 
  47   1        ADC0832_DIO=0;    //DI置0，选择通道0
  48   1        ADC0832_CLK=1;    //第三个脉冲
  49   1        ADC0832_CLK=0;    //第三个脉冲下降沿 
  50   1        ADC0832_DIO=1;    //第三个脉冲下沉之后，输入端DIO失去作用，应置1
  51   1        ADC0832_CLK=1;    //第四个脉冲
  52   1        for(i=0;i<8;i++)  //高位在前
  53   1        {
  54   2          ADC0832_CLK=1;         //第四个脉冲
C51 COMPILER V9.56.0.0   C51                                                               07/13/2019 22:55:13 PAGE 2   

  55   2          ADC0832_CLK=0; 
  56   2          dat<<=1;            //将下面储存的低位数据向右移
  57   2          dat|=(unsigned char)ADC0832_DIO;   //将输出数据DIO通过或运算储存在dat最低位 
  58   2        }               
  59   1        ADC0832_CS=1;          //片选无效 
  60   1        return dat;           //将读出的数据返回
  61   1      }
  62          
  63          
  64          /********************************************************************
  65          * 名称 : delay()
  66          * 功能 : 小延时。                          
  67          * 输入 : 无
  68          * 输出 : 无
  69          ***********************************************************************/
  70          void delay(uint T)            //延时函数
  71          {
  72   1        while(T--);
  73   1      }
  74          /********************************************************************
  75          * 名称 : LCD1602_write(uchar order,dat)
  76          * 功能 : 1602写如数据函数
  77          * 输入 : 输入的命令值
  78          * 输出 : 无
  79          ***********************************************************************/
  80          void LCD1602_write(uchar order,dat)         //1602 一个字节  处理
  81          {
  82   1          LCD1602_e=0;
  83   1          LCD1602_rs=order;
  84   1          LCD1602_dat=dat;
  85   1          LCD1602_rw=0;
  86   1          LCD1602_e=1;
  87   1          delay(1);
  88   1          LCD1602_e=0;                                                     
  89   1      }
  90          /********************************************************************
  91          * 名称 : LCD1602_writebye(uchar *prointer)
  92          * 功能 : 1602写入数据函数  指针式
  93          * 输入 : 输入的命令值
  94          * 输出 : 无
  95          ***********************************************************************/
  96          void LCD1602_writebyte(uchar *prointer)          //1602 字符串    处理
  97          {
  98   1          while(*prointer!='\0')
  99   1          {
 100   2              LCD1602_write(1,*prointer);
 101   2              prointer++;
 102   2          }
 103   1      }
 104          /********************************************************************
 105          * 名称 : LCD1602_cls()
 106          * 功能 : 初始化1602液晶 
 107          * 输入 : 无
 108          * 输出 : 无
 109          ***********************************************************************/
 110          void LCD1602_cls()                   //1602 初始化
 111          {
 112   1        LCD1602_write(0,0x01);     //1602 清屏 指令
 113   1        delay(1500);
 114   1        LCD1602_write(0,0x38);     // 功能设置 8位、5*7点阵
 115   1        delay(1500);
 116   1        LCD1602_write(0,0x0c);     //设置 光标   不显示开关、不显示光标、字符不闪烁
C51 COMPILER V9.56.0.0   C51                                                               07/13/2019 22:55:13 PAGE 3   

 117   1        LCD1602_write(0,0x06);
 118   1        LCD1602_write(0,0xd0);
 119   1        delay(1500);
 120   1      }
 121          /********************************************************************
 122          * 名称 : show()
 123          * 功能 : LCD1602液晶显示程序 
 124          * 输入 : 无
 125          * 输出 : 无
 126          ***********************************************************************/
 127          void show()
 128          {
 129   1        if(state==0)    //当前水位及工作模式显示
 130   1        {
 131   2          
 132   2          LCD1602_write(0,0x80);
 133   2          LCD1602_writebyte("Water level:");  //当前水位
 134   2          LCD1602_write(0,0x80+12);
 135   2          if(RH>9)LCD1602_write(1,0x30+RH/10%10);  //十位
 136   2          else LCD1602_writebyte(" ");
 137   2          LCD1602_write(0,0x80+13);
 138   2          LCD1602_write(1,0x30+RH%10);    //个位
 139   2          LCD1602_write(0,0x80+14);
 140   2          LCD1602_writebyte("cm");
 141   2      
 142   2          LCD1602_write(0,0xC0);  
 143   2          LCD1602_writebyte("State:");    //工作模式
 144   2          LCD1602_write(0,0xC0+6);
 145   2          if(zt==0)
 146   2          {
 147   3            LCD1602_writebyte("Manul     ");
 148   3          }else
 149   2          {
 150   3            LCD1602_writebyte(" Auto     ");
 151   3          }
 152   2            
 153   2        }
 154   1        else      //水位上下限设置界面
 155   1        {
 156   2          LCD1602_write(0,0x80);
 157   2          LCD1602_writebyte("Water_H:");   //水位上限
 158   2          LCD1602_write(0,0x80+8);
 159   2          if(state==1&&s1==1)      //通过闪烁标志为  达到闪烁的效果
 160   2          {
 161   3            LCD1602_writebyte("  ");
 162   3          }else
 163   2          { LCD1602_write(0,0x80+8);
 164   3            if(RH_H>9)LCD1602_write(1,0x30+RH_H/10%10);
 165   3            else LCD1602_writebyte(" ");
 166   3            LCD1602_write(0,0x80+9);
 167   3            LCD1602_write(1,0x30+RH_H%10);    
 168   3          }
 169   2          LCD1602_write(0,0x80+10);
 170   2          LCD1602_writebyte("cm    ");
 171   2      
 172   2          LCD1602_write(0,0xC0);
 173   2          LCD1602_writebyte("Water_L:");  //水位下限
 174   2          if(state==2&&s1==1)    //通过闪烁标志为  达到闪烁的效果
 175   2          {
 176   3            LCD1602_write(0,0xC0+8);
 177   3            LCD1602_writebyte("  "); 
 178   3          }else
C51 COMPILER V9.56.0.0   C51                                                               07/13/2019 22:55:13 PAGE 4   

 179   2          {
 180   3            LCD1602_write(0,0xC0+8);
 181   3            if(RH_L>9)LCD1602_write(1,0x30+RH_L/10%10);
 182   3            else LCD1602_writebyte(" ");
 183   3            LCD1602_write(0,0xC0+9);
 184   3            LCD1602_write(1,0x30+RH_L%10);
 185   3          }
 186   2          LCD1602_write(0,0xC0+10);
 187   2          LCD1602_writebyte("cm    ");  
 188   2        }
 189   1      }
 190          /********************************************************************
 191          * 名称 : key()
 192          * 功能 : 按键控制程序     实现系统各个控制功能 
 193          * 输入 : 无
 194          * 输出 : 无
 195          ***********************************************************************/
 196          void key()
 197          {
 198   1        if(!key_1) //设置按键  设置  功能：切换显示及设置的选项
 199   1        {
 200   2          delay(888);   //按键去抖
 201   2          if(!key_1)  //再次判断按键
 202   2          {
 203   3            while(!key_1) show();  //按键判断是否释放
 204   3            state=(state+1)%3;    //执行按键功能   切换设置项
 205   3          }
 206   2        }
 207   1      
 208   1        if(!key_2)   //切换设置项值的大小    及非设置模式下切换系统工作模式按键
 209   1        {
 210   2          delay(888);   //按键去抖
 211   2          if(!key_2)   //再次判断按键
 212   2          {
 213   3            while(!key_2)show();  //按键判断是否释放
 214   3            if(state==1)      //执行按键功能   切换设置项
 215   3            {
 216   4              if(RH_H<100)RH_H++;      //设置上限值
 217   4              SectorErase(0x2000);   //保存上限值  保存到单片机中EEPROM
 218   4              byte_write(0x2000,RH_H);     //字节写入
 219   4            }
 220   3            else if(state==2)
 221   3            {
 222   4              if(RH_L<RH_H-1)RH_L++;    //设置下限值
 223   4              SectorErase(0x2200);   //保存下限值  保存到单片机中EEPROM
 224   4              byte_write(0x2200,RH_L);     //字节写入
 225   4            }
 226   3            else
 227   3            {
 228   4              zt=!zt;        //切换系统的工作模式   自动   手动
 229   4              alarm_1=1;   //关闭继电器  
 230   4            } 
 231   3          }
 232   2        }
 233   1      
 234   1        if(!key_3)    //切换设置项值的大小    及手动模式下切换系统工作状态‘开关’
 235   1        {
 236   2          delay(888); //按键去抖
 237   2          if(!key_3)    //再次判断按键
 238   2          {   
 239   3            while(!key_3)show();  //按键判断是否释放
 240   3            if(state==1)      //执行按键功能   切换设置项
C51 COMPILER V9.56.0.0   C51                                                               07/13/2019 22:55:13 PAGE 5   

 241   3            {
 242   4              if(RH_H>RH_L+1)RH_H--;
 243   4              SectorErase(0x2000);   //保存上限值  保存到单片机中EEPROM
 244   4              byte_write(0x2000,RH_H);
 245   4            }else if(state==2)
 246   3            {
 247   4              if(RH_L>0)RH_L--;
 248   4              SectorErase(0x2200);   //保存下限值 保存到单片机中EEPROM
 249   4              byte_write(0x2200,RH_L);
 250   4            }else
 251   3            {
 252   4              if(zt==0)
 253   4              {
 254   5                alarm_1=!alarm_1;    //手动模式切换系统的工作状态
 255   5              }
 256   4            }
 257   3          }
 258   2        }   
 259   1      }
 260          /********************************************************************
 261          * 名称 : proc()
 262          * 功能 : 系统处理程序部分 
 263          * 输入 : 无
 264          * 输出 : 无
 265          ***********************************************************************/
 266          void proc()
 267          {
 268   1        if(zt==1)   //zt==1  为自动模式    如果系统在自动模式下
 269   1        {
 270   2          if(RH>=RH_H)     //如果当前水位值达到水位上限值则
 271   2          {
 272   3            alarm_1=1;   //关闭继电器   
 273   3            led_1=0;    //显示对应的指示灯
 274   3          }
 275   2          else      //否则 
 276   2          {
 277   3            led_1=1;     //显示对应的指示灯
 278   3          }
 279   2      
 280   2          if(RH<=RH_L)     //如果当前水位值低于水位下限值则
 281   2          {
 282   3            alarm_1=0;   //开启继电器 
 283   3            led_2=0;     //显示对应的指示灯
 284   3          }else     //否则 
 285   2          {
 286   3            led_2=1;     //显示对应的指示灯
 287   3          }
 288   2      
 289   2          if(RH>=RH_H||RH<=RH_L)  //蜂鸣器处理部分   如果当前水位超出水位上下限  则
 290   2          {
 291   3            beep1=1;       //开始报警
 292   3          }else    //否则
 293   2          {
 294   3            beep1=0;     //停止报警
 295   3          }
 296   2        }
 297   1        else
 298   1        {
 299   2          beep1=0;     //手动模式关闭指示灯及蜂鸣器
 300   2          led_1=led_2=1;
 301   2        }
 302   1      }
C51 COMPILER V9.56.0.0   C51                                                               07/13/2019 22:55:13 PAGE 6   

 303          
 304          /********************************************************************
 305          * 名称 : UART_1_init()
 306          * 功能 : 定时器配置初始化
 307          * 输入 : 无
 308          * 输出 : 无
 309          ***********************************************************************/
 310          void UART_1_init()
 311          {
 312   1        TMOD=0x01;    //定时器配置初始化
 313   1        TH0=0x3c;     //16位定时   定时50ms
 314   1        TL0=0xb0;
 315   1        ET0=1;
 316   1        TR0=1;     //开启总中断    及打开定时器0
 317   1        EA=1;
 318   1      }
 319          
 320          
 321          
 322          void main()
 323          { 
 324   1        float Ad_dat=0;
 325   1        alarm_1=1;      //继电器状态初始化
 326   1        UART_1_init();   //定时器配置初始化
 327   1        LCD1602_cls();     //LCD1602  初始化
 328   1        RH_H=byte_read(0x2000);    //读取EEPROM中的水位上下限的值
 329   1        RH_L=byte_read(0x2200);
 330   1        if((RH_H>99)||(RH_L>99)||(RH_L>=RH_H))   {RH_H=14;  RH_L=7;} //如果超出水位上下限设置的范围，则重新赋值
 331   1           
 332   1        while(1)
 333   1        {
 334   2          if(cs<10)       // 滤 //数字滤波器   是ADC0832读出的值变化幅度小
 335   2          {
 336   3            cs++;
 337   3            sum+=A_D();   // 波    //读取10次 AD值
 338   3          }
 339   2          else            // 算
 340   2          {
 341   3            cs=0;         // 法
 342   3            Ad_dat=(uchar)(sum/10);  //求出当前水位值
 343   3            if(Ad_dat>2)
 344   3            {
 345   4              Ad_dat=(float)((Ad_dat-2)/2.6);  //计算水位
 346   4              RH=(uchar)(Ad_dat); 
 347   4            }
 348   3            else
 349   3            RH=0;   
 350   3            sum=0;
 351   3          }   
 352   2          show();   //调用子程序
 353   2          key();
 354   2          proc();
 355   2        }
 356   1      }
 357          
 358          void UART_1() interrupt 1  //定时器0 中断
 359          {
 360   1        TH0=0x3c;      //重新赋值
 361   1        TL0=0xb0;
 362   1        ms++;       //50ms计数
 363   1        if(ms%5==0)   //250ms  计时
 364   1        {
C51 COMPILER V9.56.0.0   C51                                                               07/13/2019 22:55:13 PAGE 7   

 365   2            s1=!s1;     //改变闪烁标志为的值
 366   2        }
 367   1        if(ms%10==0)     //500ms定时
 368   1        {
 369   2          if(beep1==1) //蜂鸣器报警处理   
 370   2          {
 371   3            beep=!beep;
 372   3          }
 373   2          else
 374   2          {
 375   3            beep=1;
 376   3          } 
 377   2        }
 378   1        if(ms>19)
 379   1        {
 380   2          ms=0;
 381   2        } 
 382   1      }
 383          
 384          
 385          
 386          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1204    ----
   CONSTANT SIZE    =     75    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      8       7
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
